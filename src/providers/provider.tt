<#@ template language="C#" #>
<#@ output extension=".cs"#>
<#@ parameter name='NAME' #>
<#@ parameter name='CONV' #>
<#@ parameter name='KIND' #>
<#@ parameter name='NAME_FOR_DLLIMPORT' #>
<#@ parameter name='FEATURE_WIN32DIR' #>
<#@ parameter name='FEATURE_LOADEXTENSION' #>
<#@ parameter name='FEATURE_FUNCPTRS' #>
<#@ parameter name='FEATURE_KEY' #>
/*
   Copyright 2014-2021 SourceGear, LLC

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

// Copyright Â© Microsoft Open Technologies, Inc.
// All Rights Reserved
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
// 
// See the Apache 2 License for the specific language governing permissions and limitations under the License.

<#
	if (
		(KIND == "dynamic")
		|| (KIND == "dllimport")
		)
	{
	}
	else
	{
		throw new NotImplementedException();
	}
	if (
		(FEATURE_FUNCPTRS == "FEATURE_FUNCPTRS/false")
		|| (FEATURE_FUNCPTRS == "FEATURE_FUNCPTRS/callingconv")
		|| (FEATURE_FUNCPTRS == "FEATURE_FUNCPTRS/plain")
		)
	{
	}
	else
	{
		throw new NotImplementedException("invalid value for FEATURE_FUNCPTRS");
	}
#>
namespace SQLitePCL
{
    using System;
    using System.Collections.Generic;
<#
    if (FEATURE_FUNCPTRS == "FEATURE_FUNCPTRS/callingconv")
    {
#>
    using System.Runtime.CompilerServices;
<#
    }
#>
    using System.Runtime.InteropServices;
	using System.Reflection;
	using System.Text;

	[Preserve(AllMembers = true)]
    public sealed class SQLite3Provider_<#= NAME #> : ISQLite3Provider
    {
		const CallingConvention CALLING_CONVENTION = CallingConvention.<#= CONV #>;

		static readonly bool IsArm64cc =
			RuntimeInformation.ProcessArchitecture == Architecture.Arm64 &&
			(RuntimeInformation.IsOSPlatform(OSPlatform.OSX) || RuntimeInformation.IsOSPlatform(OSPlatform.Create("IOS")));

<#
	if (KIND == "dynamic")
	{
#>
        private static string _native_library_name;
		public static void Setup(string name, IGetFunctionPointer gf)
		{
            _native_library_name = name;
			NativeMethods.Setup(gf);
		}
        string ISQLite3Provider.GetNativeLibraryName()
        {
            return _native_library_name;
        }
<#
	}
    else if (KIND == "dllimport")
    {
#>
        string ISQLite3Provider.GetNativeLibraryName()
        {
            return "<#= NAME_FOR_DLLIMPORT #>";
        }
<#
    }
#>

        bool my_streq(IntPtr p, IntPtr q, int len)
        {
            return 0 == NativeMethods.sqlite3_strnicmp(p, q, len);
        }

        hook_handles get_hooks(sqlite3 db)
        {
			return db.GetOrCreateExtra<hook_handles>(() => new hook_handles(my_streq));
        }

        unsafe int ISQLite3Provider.sqlite3_win32_set_directory(int typ, utf8z path)
        {
<#
	if (FEATURE_WIN32DIR == "FEATURE_WIN32DIR/true")
    {
#>
            fixed (byte* p = path)
            {
                return NativeMethods.sqlite3_win32_set_directory8((uint) typ, p);
            }
<#
    }
    else
    {
#>
            return raw.SQLITE_ERROR;
<#
    }
#>
        }

        unsafe int ISQLite3Provider.sqlite3_open(utf8z filename, out IntPtr db)
        {
            fixed (byte* p = filename)
            {
                return NativeMethods.sqlite3_open(p, out db);
            }
        }

        unsafe int ISQLite3Provider.sqlite3_open_v2(utf8z filename, out IntPtr db, int flags, utf8z vfs)
        {
            fixed (byte* p_filename = filename, p_vfs = vfs)
            {
                return NativeMethods.sqlite3_open_v2(p_filename, out db, flags, p_vfs);
            }
        }

		#pragma warning disable 649
		private struct sqlite3_vfs
		{
			public int iVersion;
			public int szOsFile;
			public int mxPathname;
			public IntPtr pNext;
			public IntPtr zName;
			public IntPtr pAppData;
			public IntPtr xOpen;
			public SQLiteDeleteDelegate xDelete;
			public IntPtr xAccess;
			public IntPtr xFullPathname;
			public IntPtr xDlOpen;
			public IntPtr xDlError;
			public IntPtr xDlSym;
			public IntPtr xDlClose;
			public IntPtr xRandomness;
			public IntPtr xSleep;
			public IntPtr xCurrentTime;
			public IntPtr xGetLastError;

			[UnmanagedFunctionPointer(CALLING_CONVENTION)]
			public unsafe delegate int SQLiteDeleteDelegate(IntPtr pVfs, byte* zName, int syncDir);
		}
		#pragma warning restore 649
		
		unsafe int ISQLite3Provider.sqlite3__vfs__delete(utf8z vfs, utf8z filename, int syncDir)
		{
            fixed (byte* p_vfs = vfs, p_filename = filename)
            {
                IntPtr ptrVfs = NativeMethods.sqlite3_vfs_find(p_vfs);
                // this code and the struct it uses was taken from aspnet/DataCommon.SQLite, Apache License 2.0
                sqlite3_vfs vstruct = (sqlite3_vfs) Marshal.PtrToStructure(ptrVfs, typeof(sqlite3_vfs));
                return vstruct.xDelete(ptrVfs, p_filename, 1);
            }
		}

        int ISQLite3Provider.sqlite3_close_v2(IntPtr db)
        {
            var rc = NativeMethods.sqlite3_close_v2(db);
			return rc;
        }

        int ISQLite3Provider.sqlite3_close(IntPtr db)
        {
            var rc = NativeMethods.sqlite3_close(db);
			return rc;
        }

        IntPtr ISQLite3Provider.sqlite3_malloc(int n)
        {
            return NativeMethods.sqlite3_malloc(n);
        }

        IntPtr ISQLite3Provider.sqlite3_malloc64(ulong n)
        {
            return NativeMethods.sqlite3_malloc64(n);
        }

        void ISQLite3Provider.sqlite3_free(IntPtr p)
        {
            NativeMethods.sqlite3_free(p);
        }

        int ISQLite3Provider.sqlite3_stricmp(IntPtr p, IntPtr q)
        {
            return NativeMethods.sqlite3_stricmp(p, q);
        }

        int ISQLite3Provider.sqlite3_strnicmp(IntPtr p, IntPtr q, int n)
        {
            return NativeMethods.sqlite3_strnicmp(p, q, n);
        }

        int ISQLite3Provider.sqlite3_enable_shared_cache(int enable)
        {
            return NativeMethods.sqlite3_enable_shared_cache(enable);
        }

        void ISQLite3Provider.sqlite3_interrupt(sqlite3 db)
        {
            NativeMethods.sqlite3_interrupt(db);
        }

<#
    // FEATURE_FUNCPTRS switches from using 
    // UnmanagedFunctionPointerAttribute with a delegate and MonoPInvokeCallback
    // to
    // UnmanagedCallersOnly and C# 9.3 function pointers, requiring .NET 5 min
    bool USE_FUNCPTRS = (FEATURE_FUNCPTRS != "FEATURE_FUNCPTRS/false");
    string get_monopinvokecallback_attr(string cb)
    {
        if (FEATURE_FUNCPTRS == "FEATURE_FUNCPTRS/plain")
        {
            return "[UnmanagedCallersOnly]";
        }
        else if (FEATURE_FUNCPTRS == "FEATURE_FUNCPTRS/callingconv")
        {
            return $"[UnmanagedCallersOnly (CallConvs = new[] {{ typeof(CallConv{CONV}) }})]";
        }
        else
        {
            return $"[MonoPInvokeCallback (typeof(NativeMethods.callback_{cb}))]";
        }
    }

    string get_cb_delegate_field(string cb)
    {
        if (FEATURE_FUNCPTRS != "FEATURE_FUNCPTRS/false")
        {
            return "";
        }
        else
        {
            return $"readonly NativeMethods.callback_{cb} {cb}_hook_bridge = new NativeMethods.callback_{cb}({cb}_hook_bridge_impl);";
        }
    }

    string get_cb_type(string cb)
    {
        if (FEATURE_FUNCPTRS != "FEATURE_FUNCPTRS/false")
        {
            string callingconv;
            if (FEATURE_FUNCPTRS == "FEATURE_FUNCPTRS/callingconv")
            {
                callingconv = $"[{CONV}]";
            }
            else
            {
                callingconv = "";
            }
            switch (cb)
            {
                case "exec":
                    return $"delegate* unmanaged{callingconv} <IntPtr, int, IntPtr, IntPtr, int>";
                case "commit":
                    return $"delegate* unmanaged{callingconv} <IntPtr, int>";
                case "scalar_function":
                    return $"delegate* unmanaged{callingconv} <IntPtr, int, IntPtr, void>";
                case "agg_function_step":
                    return $"delegate* unmanaged{callingconv} <IntPtr, int, IntPtr, void>";
                case "agg_function_final":
                    return $"delegate* unmanaged{callingconv} <IntPtr, void>";
                case "log":
                    return $"delegate* unmanaged{callingconv} <IntPtr, int, IntPtr, void>";
                case "collation":
                    return $"delegate* unmanaged{callingconv} <IntPtr, int, IntPtr, int, IntPtr, int>";
                case "rollback":
                    return $"delegate* unmanaged{callingconv} <IntPtr, void>";
                case "update":
                    return $"delegate* unmanaged{callingconv} <IntPtr, int, IntPtr, IntPtr, Int64, void>";
                case "trace":
                    return $"delegate* unmanaged{callingconv} <IntPtr, IntPtr, void>";
                case "profile":
                    return $"delegate* unmanaged{callingconv} <IntPtr, IntPtr, long, void>";
                case "progress_handler":
                    return $"delegate* unmanaged{callingconv} <IntPtr, int>";
                case "authorizer":
                    return $"delegate* unmanaged{callingconv} <IntPtr, int, IntPtr, IntPtr, IntPtr, IntPtr, int>";
                default:
                    throw new NotImplementedException();
            }
        }
        else
        {
            return $"NativeMethods.callback_{cb}";
        }
    }

    string get_cb_val_field(string cb)
    {
        if (FEATURE_FUNCPTRS != "FEATURE_FUNCPTRS/false")
        {
            return $"&{cb}_hook_bridge_impl";
        }
        else
        {
            return $"{cb}_hook_bridge";
        }
    }

    string get_cb_val_nofield(string cb)
    {
        if (FEATURE_FUNCPTRS != "FEATURE_FUNCPTRS/false")
        {
            return $"&{cb}_hook_bridge_impl";
        }
        else
        {
            return $"{cb}_hook_bridge_impl";
        }
    }

    string get_cb_arg(string cb)
    {
        if (FEATURE_FUNCPTRS != "FEATURE_FUNCPTRS/false")
        {
            return $"(IntPtr) {cb}";
        }
        else
        {
            return cb;
        }
    }

    string get_cb_null()
    {
        if (FEATURE_FUNCPTRS != "FEATURE_FUNCPTRS/false")
        {
            return "IntPtr.Zero";
        }
        else
        {
            return "null";
        }
    }
#>
        <#= get_monopinvokecallback_attr("exec") #>
        static int exec_hook_bridge_impl(IntPtr p, int n, IntPtr values_ptr, IntPtr names_ptr)
        {
            exec_hook_info hi = exec_hook_info.from_ptr(p);
            return hi.call(n, values_ptr, names_ptr);
        }
		// shouldn't there be a impl/bridge thing here?  no, because this callback is not stored so it doesn't need further GC protection

        <#= USE_FUNCPTRS?"unsafe ":"" #>int ISQLite3Provider.sqlite3_exec(sqlite3 db, utf8z sql, delegate_exec func, object user_data, out IntPtr errMsg)
        {
            int rc;

			<#= get_cb_type("exec") #> cb;
			exec_hook_info hi;
            if (func != null)
            {
				cb = <#= get_cb_val_nofield("exec") #>;
                hi = new exec_hook_info(func, user_data);
            }
            else
            {
				cb = null;
                hi = null;
            }
			var h = new hook_handle(hi);
            unsafe
            {
                fixed (byte* p_sql = sql)
                {
                    rc = NativeMethods.sqlite3_exec(db, p_sql, <#= get_cb_arg("cb") #>, h, out errMsg);
                }
            }
			h.Dispose();

            return rc;
        }

        unsafe int ISQLite3Provider.sqlite3_complete(utf8z sql)
        {
            fixed (byte* p = sql)
            {
                return NativeMethods.sqlite3_complete(p);
            }
        }

        unsafe utf8z ISQLite3Provider.sqlite3_compileoption_get(int n)
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_compileoption_get(n));
        }

        unsafe int ISQLite3Provider.sqlite3_compileoption_used(utf8z s)
        {
            fixed (byte* p = s)
            {
                return NativeMethods.sqlite3_compileoption_used(p);
            }
        }

        unsafe int ISQLite3Provider.sqlite3_table_column_metadata(sqlite3 db, utf8z dbName, utf8z tblName, utf8z colName, out utf8z dataType, out utf8z collSeq, out int notNull, out int primaryKey, out int autoInc)
        {
            fixed (byte* p_dbName = dbName, p_tblName = tblName, p_colName = colName)
            {
                var rc = NativeMethods.sqlite3_table_column_metadata(
                            db, p_dbName, p_tblName, p_colName, 
                            out var p_dataType, out var p_collSeq, out notNull, out primaryKey, out autoInc);
                dataType = utf8z.FromPtr(p_dataType);
                collSeq = utf8z.FromPtr(p_collSeq);
                return rc;
            }
        }

        unsafe int ISQLite3Provider.sqlite3_key(sqlite3 db, ReadOnlySpan<byte> k)
        {
<#
	if (FEATURE_KEY == "FEATURE_KEY/true")
    {
#>
            fixed (byte* p = k)
            {
                return NativeMethods.sqlite3_key(db, p, k.Length);
            }
<#
    }
    else
    {
#>
            return raw.SQLITE_ERROR;
<#
    }
#>
        }

        unsafe int ISQLite3Provider.sqlite3_key_v2(sqlite3 db, utf8z name, ReadOnlySpan<byte> k)
        {
<#
	if (FEATURE_KEY == "FEATURE_KEY/true")
    {
#>
            fixed (byte* p = k, p_name = name)
            {
                return NativeMethods.sqlite3_key_v2(db, p_name, p, k.Length);
            }
<#
    }
    else
    {
#>
            return raw.SQLITE_ERROR;
<#
    }
#>
        }

        unsafe int ISQLite3Provider.sqlite3_rekey(sqlite3 db, ReadOnlySpan<byte> k)
        {
<#
	if (FEATURE_KEY == "FEATURE_KEY/true")
    {
#>
            fixed (byte* p = k)
            {
                return NativeMethods.sqlite3_rekey(db, p, k.Length);
            }
<#
    }
    else
    {
#>
            return raw.SQLITE_ERROR;
<#
    }
#>
        }

        unsafe int ISQLite3Provider.sqlite3_rekey_v2(sqlite3 db, utf8z name, ReadOnlySpan<byte> k)
        {
<#
	if (FEATURE_KEY == "FEATURE_KEY/true")
    {
#>
            fixed (byte* p = k, p_name = name)
            {
                return NativeMethods.sqlite3_rekey_v2(db, p_name, p, k.Length);
            }
<#
    }
    else
    {
#>
            return raw.SQLITE_ERROR;
<#
    }
#>
        }

        unsafe int ISQLite3Provider.sqlite3_prepare_v2(sqlite3 db, ReadOnlySpan<byte> sql, out IntPtr stm, out ReadOnlySpan<byte> tail)
        {
            fixed (byte* p_sql = sql)
            {
                var rc = NativeMethods.sqlite3_prepare_v2(db, p_sql, sql.Length, out stm, out var p_tail);
                var len_consumed = (int) (p_tail - p_sql);
                int len_remain = sql.Length - len_consumed;
                if (len_remain > 0)
                {
                    tail = sql.Slice(len_consumed, len_remain);
                }
                else
                {
                    tail = ReadOnlySpan<byte>.Empty;
                }
                return rc;
            }
        }

        unsafe int ISQLite3Provider.sqlite3_prepare_v2(sqlite3 db, utf8z sql, out IntPtr stm, out utf8z tail)
        {
// TODO obsolete.  just throw?
            fixed (byte* p_sql = sql)
            {
                var rc = NativeMethods.sqlite3_prepare_v2(db, p_sql, -1, out stm, out var p_tail);
                // TODO we could skip the strlen by using the length we were given
                tail = utf8z.FromPtr(p_tail);
                return rc;
            }
        }

        unsafe int ISQLite3Provider.sqlite3_prepare_v3(sqlite3 db, ReadOnlySpan<byte> sql, uint flags, out IntPtr stm, out ReadOnlySpan<byte> tail)
        {
            fixed (byte* p_sql = sql)
            {
                var rc = NativeMethods.sqlite3_prepare_v3(db, p_sql, sql.Length, flags, out stm, out var p_tail);
                var len_consumed = (int) (p_tail - p_sql);
                int len_remain = sql.Length - len_consumed;
                if (len_remain > 0)
                {
                    tail = sql.Slice(len_consumed, len_remain);
                }
                else
                {
                    tail = ReadOnlySpan<byte>.Empty;
                }
                return rc;
            }
        }

        unsafe int ISQLite3Provider.sqlite3_prepare_v3(sqlite3 db, utf8z sql, uint flags, out IntPtr stm, out utf8z tail)
        {
// TODO obsolete.  just throw?
            fixed (byte* p_sql = sql)
            {
                var rc = NativeMethods.sqlite3_prepare_v3(db, p_sql, -1, flags, out stm, out var p_tail);
                // TODO we could skip the strlen by using the length we were given
                tail = utf8z.FromPtr(p_tail);
                return rc;
            }
        }

        int ISQLite3Provider.sqlite3_db_status(sqlite3 db, int op, out int current, out int highest, int resetFlg)
        {
            return NativeMethods.sqlite3_db_status(db, op, out current, out highest, resetFlg);
        }

        unsafe utf8z ISQLite3Provider.sqlite3_sql(sqlite3_stmt stmt)
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_sql(stmt));
        }

        IntPtr ISQLite3Provider.sqlite3_db_handle(IntPtr stmt)
        {
            return NativeMethods.sqlite3_db_handle(stmt);
        }

        unsafe int ISQLite3Provider.sqlite3_blob_open(sqlite3 db, utf8z db_utf8, utf8z table_utf8, utf8z col_utf8, long rowid, int flags, out sqlite3_blob blob)
        {
            fixed (byte* p_db = db_utf8, p_table = table_utf8, p_col = col_utf8)
            {
                return NativeMethods.sqlite3_blob_open(db, p_db, p_table, p_col, rowid, flags, out blob);
            }
        }

        int ISQLite3Provider.sqlite3_blob_bytes(sqlite3_blob blob)
        {
            return NativeMethods.sqlite3_blob_bytes(blob);
        }

        int ISQLite3Provider.sqlite3_blob_reopen(sqlite3_blob blob, long rowid)
        {
            return NativeMethods.sqlite3_blob_reopen(blob, rowid);
        }

        unsafe int ISQLite3Provider.sqlite3_blob_read(sqlite3_blob blob, Span<byte> b, int offset)
        {
            fixed (byte* p = b)
            {
                return NativeMethods.sqlite3_blob_read(blob, p, b.Length, offset);
            }
        }

        unsafe int ISQLite3Provider.sqlite3_blob_write(sqlite3_blob blob, ReadOnlySpan<byte> b, int offset)
        {
            fixed (byte* p = b)
            {
                return NativeMethods.sqlite3_blob_write(blob, p, b.Length, offset);
            }
        }

        int ISQLite3Provider.sqlite3_blob_close(IntPtr blob)
        {
            return NativeMethods.sqlite3_blob_close(blob);
        }

        unsafe int ISQLite3Provider.sqlite3_snapshot_get(sqlite3 db, utf8z schema, out IntPtr snap)
        {
            fixed (byte* p_schema = schema)
            {
                return NativeMethods.sqlite3_snapshot_get(db, p_schema, out snap);
            }
        }

        int ISQLite3Provider.sqlite3_snapshot_cmp(sqlite3_snapshot p1, sqlite3_snapshot p2)
        {
            return NativeMethods.sqlite3_snapshot_cmp(p1, p2);
        }

        unsafe int ISQLite3Provider.sqlite3_snapshot_open(sqlite3 db, utf8z schema, sqlite3_snapshot snap)
        {
            fixed (byte* p_schema = schema)
            {
                return NativeMethods.sqlite3_snapshot_open(db, p_schema, snap);
            }
        }

        unsafe int ISQLite3Provider.sqlite3_snapshot_recover(sqlite3 db, utf8z name)
        {
            fixed (byte* p_name = name)
            {
                return NativeMethods.sqlite3_snapshot_recover(db, p_name);
            }
        }

        void ISQLite3Provider.sqlite3_snapshot_free(IntPtr snap)
        {
            NativeMethods.sqlite3_snapshot_free(snap);
        }

        unsafe sqlite3_backup ISQLite3Provider.sqlite3_backup_init(sqlite3 destDb, utf8z destName, sqlite3 sourceDb, utf8z sourceName)
        {
            fixed (byte* p_destName = destName, p_sourceName = sourceName)
            {
                return NativeMethods.sqlite3_backup_init(destDb, p_destName, sourceDb, p_sourceName);
            }
        }

        int ISQLite3Provider.sqlite3_backup_step(sqlite3_backup backup, int nPage)
        {
            return NativeMethods.sqlite3_backup_step(backup, nPage);
        }

        int ISQLite3Provider.sqlite3_backup_remaining(sqlite3_backup backup)
        {
            return NativeMethods.sqlite3_backup_remaining(backup);
        }

        int ISQLite3Provider.sqlite3_backup_pagecount(sqlite3_backup backup)
        {
            return NativeMethods.sqlite3_backup_pagecount(backup);
        }

        int ISQLite3Provider.sqlite3_backup_finish(IntPtr backup)
        {
            return NativeMethods.sqlite3_backup_finish(backup);
        }

        IntPtr ISQLite3Provider.sqlite3_next_stmt(sqlite3 db, IntPtr stmt)
        {
            return NativeMethods.sqlite3_next_stmt(db, stmt);
        }

        long ISQLite3Provider.sqlite3_last_insert_rowid(sqlite3 db)
        {
            return NativeMethods.sqlite3_last_insert_rowid(db);
        }

        int ISQLite3Provider.sqlite3_changes(sqlite3 db)
        {
            return NativeMethods.sqlite3_changes(db);
        }

        int ISQLite3Provider.sqlite3_total_changes(sqlite3 db)
        {
            return NativeMethods.sqlite3_total_changes(db);
        }

        int ISQLite3Provider.sqlite3_extended_result_codes(sqlite3 db, int onoff)
        {
            return NativeMethods.sqlite3_extended_result_codes(db, onoff);
        }

        unsafe utf8z ISQLite3Provider.sqlite3_errstr(int rc)
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_errstr(rc));
        }

        int ISQLite3Provider.sqlite3_errcode(sqlite3 db)
        {
            return NativeMethods.sqlite3_errcode(db);
        }

        int ISQLite3Provider.sqlite3_extended_errcode(sqlite3 db)
        {
            return NativeMethods.sqlite3_extended_errcode(db);
        }

        int ISQLite3Provider.sqlite3_busy_timeout(sqlite3 db, int ms)
        {
            return NativeMethods.sqlite3_busy_timeout(db, ms);
        }

        int ISQLite3Provider.sqlite3_get_autocommit(sqlite3 db)
        {
            return NativeMethods.sqlite3_get_autocommit(db);
        }

        unsafe int ISQLite3Provider.sqlite3_db_readonly(sqlite3 db, utf8z dbName)
        {
            fixed (byte* p_dbName = dbName)
            {
                return NativeMethods.sqlite3_db_readonly(db, p_dbName); 
            }
        }
        
        unsafe utf8z ISQLite3Provider.sqlite3_db_filename(sqlite3 db, utf8z att)
		{
            fixed (byte* p_att = att)
            {
                return utf8z.FromPtr(NativeMethods.sqlite3_db_filename(db, p_att));
            }
		}

        unsafe utf8z ISQLite3Provider.sqlite3_errmsg(sqlite3 db)
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_errmsg(db));
        }

        unsafe utf8z ISQLite3Provider.sqlite3_libversion()
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_libversion());
        }

        int ISQLite3Provider.sqlite3_libversion_number()
        {
            return NativeMethods.sqlite3_libversion_number();
        }

        int ISQLite3Provider.sqlite3_threadsafe()
        {
            return NativeMethods.sqlite3_threadsafe();
        }

        int ISQLite3Provider.sqlite3_config(int op)
        {
            return NativeMethods.sqlite3_config_none(op);
        }

        int ISQLite3Provider.sqlite3_config(int op, int val)
        {
            if (IsArm64cc)
                return NativeMethods.sqlite3_config_int_arm64cc(op, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, val);

            return NativeMethods.sqlite3_config_int(op, val);
        }

        unsafe int ISQLite3Provider.sqlite3_db_config(sqlite3 db, int op, utf8z val)
        {
            fixed (byte* p_val = val)
            {
                if (IsArm64cc)
                    return NativeMethods.sqlite3_db_config_charptr_arm64cc(db, op, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, p_val);

                return NativeMethods.sqlite3_db_config_charptr(db, op, p_val);
            }
        }

        unsafe int ISQLite3Provider.sqlite3_db_config(sqlite3 db, int op, int val, out int result)
        {
            int out_result = 0;
            int native_result;

            if (IsArm64cc)
                native_result = NativeMethods.sqlite3_db_config_int_outint_arm64cc(db, op, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, val, &out_result);
            else
                native_result = NativeMethods.sqlite3_db_config_int_outint(db, op, val, &out_result);

            result = out_result;

            return native_result;
        }

         int ISQLite3Provider.sqlite3_db_config(sqlite3 db, int op, IntPtr ptr, int int0, int int1)
        {
            if (IsArm64cc)
                return NativeMethods.sqlite3_db_config_intptr_int_int_arm64cc(db, op, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, ptr, int0, int1);

            return NativeMethods.sqlite3_db_config_intptr_int_int(db, op, ptr, int0, int1);
        }

        int ISQLite3Provider.sqlite3_limit(sqlite3 db, int id, int newVal)
        {
            return NativeMethods.sqlite3_limit(db, id, newVal);
        }

        int ISQLite3Provider.sqlite3_initialize()
        {
            return NativeMethods.sqlite3_initialize();
        }

        int ISQLite3Provider.sqlite3_shutdown()
        {
            return NativeMethods.sqlite3_shutdown();
        }

        int ISQLite3Provider.sqlite3_enable_load_extension(sqlite3 db, int onoff)
        {
            return NativeMethods.sqlite3_enable_load_extension(db, onoff);
        }

        unsafe int ISQLite3Provider.sqlite3_load_extension(sqlite3 db, utf8z zFile, utf8z zProc, out utf8z pzErrMsg)
        {
<#
	if (FEATURE_LOADEXTENSION == "FEATURE_LOADEXTENSION/true")
    {
#>
            fixed (byte* p_zFile = zFile, p_zProc = zProc)
            {
                var rc = NativeMethods.sqlite3_load_extension(
                            db, p_zFile, p_zProc,
                            out var p_zErrMsg);
                pzErrMsg = utf8z.FromPtr(p_zErrMsg);
                return rc;
            }
<#
    }
    else
    {
#>
            pzErrMsg = utf8z.FromPtr(null);
            return raw.SQLITE_ERROR;
<#
    }
#>
        }


        // ----------------------------------------------------------------

        // Passing a callback into SQLite is tricky.  The implementation details
        // can vary depending on the .NET implementation, so we hide these
        // in platform-specific code underneath the ISQLite3Provider boundary.
        //
        // The caller gives us a delegate and an object they want passed to that
        // delegate.  We do not actually pass that stuff down to SQLite as
        // the callback.  Instead, we store the information and pass down a bridge
        // function, with an IntPtr that can be used to retrieve the info later.
        //
        // When SQLite calls the bridge function, we lookup the info we previously
        // stored and call the delegate provided by the upper layer.
        //
        // The class we use to remember the original info (delegate and user object)
        // is shared but not portable.  It is in the util.cs file which is compiled
        // into each platform assembly.
        
        <#= get_monopinvokecallback_attr("commit") #>
        static int commit_hook_bridge_impl(IntPtr p)
        {
            commit_hook_info hi = commit_hook_info.from_ptr(p);
            return hi.call();
        }

        <#= get_cb_delegate_field("commit") #>
        <#= USE_FUNCPTRS?"unsafe ":"" #>void ISQLite3Provider.sqlite3_commit_hook(sqlite3 db, delegate_commit func, object v)
        {
			var info = get_hooks(db);
            if (info.commit != null)
            {
                // TODO maybe turn off the hook here, for now
                info.commit.Dispose();
                info.commit = null;
            }

			<#= get_cb_type("commit") #> cb;
			commit_hook_info hi;
            if (func != null)
            {
				cb = <#= get_cb_val_field("commit") #>;
                hi = new commit_hook_info(func, v);
            }
            else
            {
				cb = null;
				hi = null;
            }
			var h = new hook_handle(hi);
			NativeMethods.sqlite3_commit_hook(db, <#= get_cb_arg("cb") #>, h);
			info.commit = h.ForDispose();
        }

        // ----------------------------------------------------------------

        // Passing a callback into SQLite is tricky.  See comments near commit_hook
        // implementation in pinvoke/SQLite3Provider.cs

        <#= get_monopinvokecallback_attr("scalar_function") #>
        static void scalar_function_hook_bridge_impl(IntPtr context, int num_args, IntPtr argsptr)
        {
            IntPtr p = NativeMethods.sqlite3_user_data(context);
            function_hook_info hi = function_hook_info.from_ptr(p);
            hi.call_scalar(context, num_args, argsptr);
        }

        <#= get_cb_delegate_field("scalar_function") #>

        <#= USE_FUNCPTRS?"unsafe ":"" #>int ISQLite3Provider.sqlite3_create_function(sqlite3 db, byte[] name, int nargs, int flags, object v, delegate_function_scalar func)
        {
			var info = get_hooks(db);
            if (info.RemoveScalarFunction(name, nargs))
            {
                // TODO maybe turn off the hook here, for now
            }

            // 1 is SQLITE_UTF8
			int arg4 = 1 | flags;
			<#= get_cb_type("scalar_function") #> cb;
			function_hook_info hi;
            if (func != null)
            {
				cb = <#= get_cb_val_field("scalar_function") #>;
                hi = new function_hook_info(func, v);
            }
            else
            {
				cb = null;
				hi = null;
            }
			var h = new hook_handle(hi);
			int rc = NativeMethods.sqlite3_create_function_v2(db, name, nargs, arg4, h, <#= get_cb_arg("cb") #>, <#= get_cb_null() #>, <#= get_cb_null() #>, <#= get_cb_null() #>);
			if ((rc == 0) && (cb != null))
			{
                info.AddScalarFunction(name, nargs, h.ForDispose());
			}
			return rc;
        }

        // ----------------------------------------------------------------

		static IDisposable disp_log_hook_handle;

        <#= get_monopinvokecallback_attr("log") #>
        static void log_hook_bridge_impl(IntPtr p, int rc, IntPtr s)
        {
            log_hook_info hi = log_hook_info.from_ptr(p);
            hi.call(rc, utf8z.FromIntPtr(s));
        }

        <#= get_cb_delegate_field("log") #>
        <#= USE_FUNCPTRS?"unsafe ":"" #>int ISQLite3Provider.sqlite3_config_log(delegate_log func, object v)
        {
            if (disp_log_hook_handle != null)
            {
                // TODO maybe turn off the hook here, for now
                disp_log_hook_handle.Dispose();
                disp_log_hook_handle = null;
            }

			<#= get_cb_type("log") #> cb;
			log_hook_info hi;
            if (func != null)
            {
				cb = <#= get_cb_val_field("log") #>;
                hi = new log_hook_info(func, v);
            }
            else
            {
				cb = null;
				hi = null;
            }
			var h = new hook_handle(hi);
			disp_log_hook_handle = h; // TODO if valid
			if (IsArm64cc)
				return NativeMethods.sqlite3_config_log_arm64cc(raw.SQLITE_CONFIG_LOG, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, <#= get_cb_arg("cb") #>, h);
			return NativeMethods.sqlite3_config_log(raw.SQLITE_CONFIG_LOG, <#= get_cb_arg("cb") #>, h);
        }

        unsafe void ISQLite3Provider.sqlite3_log(int errcode, utf8z s)
        {
            fixed (byte* p = s)
            {
                NativeMethods.sqlite3_log(errcode, p);
            }
        }

        // ----------------------------------------------------------------

        // Passing a callback into SQLite is tricky.  See comments near commit_hook
        // implementation in pinvoke/SQLite3Provider.cs

        <#= get_monopinvokecallback_attr("agg_function_step") #>
        static void agg_function_step_hook_bridge_impl(IntPtr context, int num_args, IntPtr argsptr)
        {
            IntPtr agg = NativeMethods.sqlite3_aggregate_context(context, 8);
            // TODO error check agg nomem

            IntPtr p = NativeMethods.sqlite3_user_data(context);
            function_hook_info hi = function_hook_info.from_ptr(p);
            hi.call_step(context, agg, num_args, argsptr);
        }

        <#= get_monopinvokecallback_attr("agg_function_final") #>
        static void agg_function_final_hook_bridge_impl(IntPtr context)
        {
            IntPtr agg = NativeMethods.sqlite3_aggregate_context(context, 8);
            // TODO error check agg nomem

            IntPtr p = NativeMethods.sqlite3_user_data(context);
            function_hook_info hi = function_hook_info.from_ptr(p);
            hi.call_final(context, agg);
        }

        <#= get_cb_delegate_field("agg_function_step") #>
        <#= get_cb_delegate_field("agg_function_final") #>

        <#= USE_FUNCPTRS?"unsafe ":"" #>int ISQLite3Provider.sqlite3_create_function(sqlite3 db, byte[] name, int nargs, int flags, object v, delegate_function_aggregate_step func_step, delegate_function_aggregate_final func_final)
        {
			var info = get_hooks(db);
            if (info.RemoveAggFunction(name, nargs))
            {
                // TODO maybe turn off the hook here, for now
            }

            // 1 is SQLITE_UTF8
			int arg4 = 1 | flags;
			<#= get_cb_type("agg_function_step") #> cb_step;
			<#= get_cb_type("agg_function_final") #> cb_final;
			function_hook_info hi;
            if (func_step != null)
            {
                // TODO both func_step and func_final must be non-null
				cb_step = <#= get_cb_val_field("agg_function_step") #>;
				cb_final = <#= get_cb_val_field("agg_function_final") #>;
                hi = new function_hook_info(func_step, func_final, v);
            }
            else
            {
				cb_step = null;
				cb_final = null;
				hi = null;
            }
			var h = new hook_handle(hi);
			int rc = NativeMethods.sqlite3_create_function_v2(db, name, nargs, arg4, h, <#= get_cb_null() #>, <#= get_cb_arg("cb_step") #>, <#= get_cb_arg("cb_final") #>, <#= get_cb_null() #>);
			if ((rc == 0) && (cb_step != null))
			{
                info.AddAggFunction(name, nargs, h.ForDispose());
			}
			return rc;
        }

        // ----------------------------------------------------------------

        // Passing a callback into SQLite is tricky.  See comments near commit_hook
        // implementation in pinvoke/SQLite3Provider.cs

        <#= get_monopinvokecallback_attr("collation") #>
        static int collation_hook_bridge_impl(IntPtr p, int len1, IntPtr pv1, int len2, IntPtr pv2)
        {
            collation_hook_info hi = collation_hook_info.from_ptr(p);
            ReadOnlySpan<byte> s1;
            ReadOnlySpan<byte> s2;
            unsafe
            {
                s1 = new ReadOnlySpan<byte>(pv1.ToPointer(), len1);
                s2 = new ReadOnlySpan<byte>(pv2.ToPointer(), len2);
            }
            return hi.call(s1, s2);
        }

        <#= get_cb_delegate_field("collation") #>
        <#= USE_FUNCPTRS?"unsafe ":"" #>int ISQLite3Provider.sqlite3_create_collation(sqlite3 db, byte[] name, object v, delegate_collation func)
        {
			var info = get_hooks(db);
            if (info.RemoveCollation(name))
            {
                // TODO maybe turn off the hook here, for now
            }

			<#= get_cb_type("collation") #> cb;
			collation_hook_info hi;
            if (func != null)
            {
				cb = <#= get_cb_val_field("collation") #>;
                hi = new collation_hook_info(func, v);
            }
            else
            {
				cb = null;
				hi = null;
            }
			var h = new hook_handle(hi);
            // 1 is SQLITE_UTF8
			int rc = NativeMethods.sqlite3_create_collation(db, name, 1, h, <#= get_cb_arg("cb") #>);
			if ((rc == 0) && (cb != null))
			{
                info.AddCollation(name, h.ForDispose());
			}
			return rc;
        }

        // ----------------------------------------------------------------

        // Passing a callback into SQLite is tricky.  See comments near commit_hook
        // implementation in pinvoke/SQLite3Provider.cs

        <#= get_monopinvokecallback_attr("update") #>
        static void update_hook_bridge_impl(IntPtr p, int typ, IntPtr db, IntPtr tbl, Int64 rowid)
        {
            update_hook_info hi = update_hook_info.from_ptr(p);
            hi.call(typ, utf8z.FromIntPtr(db), utf8z.FromIntPtr(tbl), rowid);
        }

        <#= get_cb_delegate_field("update") #>
        <#= USE_FUNCPTRS?"unsafe ":"" #>void ISQLite3Provider.sqlite3_update_hook(sqlite3 db, delegate_update func, object v)
        {
			var info = get_hooks(db);
            if (info.update != null)
            {
                // TODO maybe turn off the hook here, for now
                info.update.Dispose();
                info.update = null;
            }

			<#= get_cb_type("update") #> cb;
			update_hook_info hi;
            if (func != null)
            {
				cb = <#= get_cb_val_field("update") #>;
                hi = new update_hook_info(func, v);
            }
            else
            {
				cb = null;
				hi = null;
            }
			var h = new hook_handle(hi);
            info.update = h.ForDispose();
			NativeMethods.sqlite3_update_hook(db, <#= get_cb_arg("cb") #>, h);
        }

        // ----------------------------------------------------------------

        // Passing a callback into SQLite is tricky.  See comments near commit_hook
        // implementation in pinvoke/SQLite3Provider.cs

        <#= get_monopinvokecallback_attr("rollback") #>
        static void rollback_hook_bridge_impl(IntPtr p)
        {
            rollback_hook_info hi = rollback_hook_info.from_ptr(p);
            hi.call();
        }

        <#= get_cb_delegate_field("rollback") #>
        <#= USE_FUNCPTRS?"unsafe ":"" #>void ISQLite3Provider.sqlite3_rollback_hook(sqlite3 db, delegate_rollback func, object v)
        {
			var info = get_hooks(db);
            if (info.rollback != null)
            {
                // TODO maybe turn off the hook here, for now
                info.rollback.Dispose();
                info.rollback = null;
            }

			<#= get_cb_type("rollback") #> cb;
			rollback_hook_info hi;
            if (func != null)
            {
				cb = <#= get_cb_val_field("rollback") #>;
                hi = new rollback_hook_info(func, v);
            }
            else
            {
				cb = null;
				hi = null;
            }
			var h = new hook_handle(hi);
			info.rollback = h.ForDispose();
			NativeMethods.sqlite3_rollback_hook(db, <#= get_cb_arg("cb") #>, h);
        }

        // ----------------------------------------------------------------

        // Passing a callback into SQLite is tricky.  See comments near commit_hook
        // implementation in pinvoke/SQLite3Provider.cs

        <#= get_monopinvokecallback_attr("trace") #>
        static void trace_hook_bridge_impl(IntPtr p, IntPtr s)
        {
            trace_hook_info hi = trace_hook_info.from_ptr(p);
            hi.call(utf8z.FromIntPtr(s));
        }

        <#= get_cb_delegate_field("trace") #>
        <#= USE_FUNCPTRS?"unsafe ":"" #>void ISQLite3Provider.sqlite3_trace(sqlite3 db, delegate_trace func, object v)
        {
			var info = get_hooks(db);
            if (info.trace != null)
            {
                // TODO maybe turn off the hook here, for now
                info.trace.Dispose();
                info.trace = null;
            }

			<#= get_cb_type("trace") #> cb;
			trace_hook_info hi;
            if (func != null)
            {
				cb = <#= get_cb_val_field("trace") #>;
                hi = new trace_hook_info(func, v);
            }
            else
            {
				cb = null;
				hi = null;
            }
			var h = new hook_handle(hi);
			info.trace = h.ForDispose();
			NativeMethods.sqlite3_trace(db, <#= get_cb_arg("cb") #>, h);
        }

        // ----------------------------------------------------------------

        // Passing a callback into SQLite is tricky.  See comments near commit_hook
        // implementation in pinvoke/SQLite3Provider.cs

        <#= get_monopinvokecallback_attr("profile") #>
        static void profile_hook_bridge_impl(IntPtr p, IntPtr s, long elapsed)
        {
            profile_hook_info hi = profile_hook_info.from_ptr(p);
            hi.call(utf8z.FromIntPtr(s), elapsed);
        }

        <#= get_cb_delegate_field("profile") #>
        <#= USE_FUNCPTRS?"unsafe ":"" #>void ISQLite3Provider.sqlite3_profile(sqlite3 db, delegate_profile func, object v)
        {
			var info = get_hooks(db);
            if (info.profile != null)
            {
                // TODO maybe turn off the hook here, for now
                info.profile.Dispose();
                info.profile = null;
            }

			<#= get_cb_type("profile") #> cb;
			profile_hook_info hi;
            if (func != null)
            {
				cb = <#= get_cb_val_field("profile") #>;
                hi = new profile_hook_info(func, v);
            }
            else
            {
				cb = null;
				hi = null;
            }
			var h = new hook_handle(hi);
			info.profile = h.ForDispose();
			NativeMethods.sqlite3_profile(db, <#= get_cb_arg("cb") #>, h);
        }

        // ----------------------------------------------------------------

        // Passing a callback into SQLite is tricky.  See comments near commit_hook
        // implementation in pinvoke/SQLite3Provider.cs

        <#= get_monopinvokecallback_attr("progress_handler") #>
        static int progress_handler_hook_bridge_impl(IntPtr p)
        {
            progress_hook_info hi = progress_hook_info.from_ptr(p);
            return hi.call();
        }

        <#= get_cb_delegate_field("progress_handler") #>
        <#= USE_FUNCPTRS?"unsafe ":"" #>void ISQLite3Provider.sqlite3_progress_handler(sqlite3 db, int instructions, delegate_progress func, object v)
        {
			var info = get_hooks(db);
            if (info.progress != null)
            {
                // TODO maybe turn off the hook here, for now
                info.progress.Dispose();
                info.progress = null;
            }

			<#= get_cb_type("progress_handler") #> cb;
			progress_hook_info hi;
            if (func != null)
            {
				cb = <#= get_cb_val_field("progress_handler") #>;
                hi = new progress_hook_info(func, v);
            }
            else
            {
				cb = null;
				hi = null;
            }
			var h = new hook_handle(hi);
			info.progress = h.ForDispose();
			NativeMethods.sqlite3_progress_handler(db, instructions, <#= get_cb_arg("cb") #>, h);
        }

        // ----------------------------------------------------------------

        // ----------------------------------------------------------------

        // Passing a callback into SQLite is tricky.  See comments near commit_hook
        // implementation in pinvoke/SQLite3Provider.cs

        <#= get_monopinvokecallback_attr("authorizer") #>
        static int authorizer_hook_bridge_impl(IntPtr p, int action_code, IntPtr param0, IntPtr param1, IntPtr dbName, IntPtr inner_most_trigger_or_view)
        {
            authorizer_hook_info hi = authorizer_hook_info.from_ptr(p);
            return hi.call(action_code, utf8z.FromIntPtr(param0), utf8z.FromIntPtr(param1), utf8z.FromIntPtr(dbName), utf8z.FromIntPtr(inner_most_trigger_or_view));
        }

        <#= get_cb_delegate_field("authorizer") #>
        <#= USE_FUNCPTRS?"unsafe ":"" #>int ISQLite3Provider.sqlite3_set_authorizer(sqlite3 db, delegate_authorizer func, object v)
        {
			var info = get_hooks(db);
            if (info.authorizer != null)
            {
                // TODO maybe turn off the hook here, for now
                info.authorizer.Dispose();
                info.authorizer = null;
            }

			<#= get_cb_type("authorizer") #> cb;
			authorizer_hook_info hi;
            if (func != null)
            {
				cb = <#= get_cb_val_field("authorizer") #>;
                hi = new authorizer_hook_info(func, v);
            }
            else
            {
				cb = null;
				hi = null;
            }
			var h = new hook_handle(hi);
			info.authorizer = h.ForDispose();
			return NativeMethods.sqlite3_set_authorizer(db, <#= get_cb_arg("cb") #>, h);
        }

        // ----------------------------------------------------------------

        long ISQLite3Provider.sqlite3_memory_used()
        {
            return NativeMethods.sqlite3_memory_used();
        }

        long ISQLite3Provider.sqlite3_memory_highwater(int resetFlag)
        {
            return NativeMethods.sqlite3_memory_highwater(resetFlag);
        }

        long ISQLite3Provider.sqlite3_soft_heap_limit64(long n)
        {
            return NativeMethods.sqlite3_soft_heap_limit64(n);
        }
        
        long ISQLite3Provider.sqlite3_hard_heap_limit64(long n)
        {
            return NativeMethods.sqlite3_hard_heap_limit64(n);
        }

        int ISQLite3Provider.sqlite3_status(int op, out int current, out int highwater, int resetFlag)
        {
            return NativeMethods.sqlite3_status(op, out current, out highwater, resetFlag);
        }

        unsafe utf8z ISQLite3Provider.sqlite3_sourceid()
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_sourceid());
        }

        void ISQLite3Provider.sqlite3_result_int64(IntPtr ctx, long val)
        {
            NativeMethods.sqlite3_result_int64(ctx, val);
        }

        void ISQLite3Provider.sqlite3_result_int(IntPtr ctx, int val)
        {
            NativeMethods.sqlite3_result_int(ctx, val);
        }

        void ISQLite3Provider.sqlite3_result_double(IntPtr ctx, double val)
        {
            NativeMethods.sqlite3_result_double(ctx, val);
        }

        void ISQLite3Provider.sqlite3_result_null(IntPtr stm)
        {
            NativeMethods.sqlite3_result_null(stm);
        }

        unsafe void ISQLite3Provider.sqlite3_result_error(IntPtr ctx, ReadOnlySpan<byte> val)
        {
            fixed (byte* p = val)
            {
                NativeMethods.sqlite3_result_error(ctx, p, val.Length);
            }
        }

        unsafe void ISQLite3Provider.sqlite3_result_error(IntPtr ctx, utf8z val)
        {
            fixed (byte* p = val)
            {
                NativeMethods.sqlite3_result_error(ctx, p, -1);
            }
        }

        unsafe void ISQLite3Provider.sqlite3_result_text(IntPtr ctx, ReadOnlySpan<byte> val)
        {
            fixed (byte* p = val)
            {
                NativeMethods.sqlite3_result_text(ctx, p, val.Length, new IntPtr(-1));
            }
        }

        unsafe void ISQLite3Provider.sqlite3_result_text(IntPtr ctx, utf8z val)
        {
            fixed (byte* p = val)
            {
                NativeMethods.sqlite3_result_text(ctx, p, -1, new IntPtr(-1));
            }
        }

        unsafe void ISQLite3Provider.sqlite3_result_blob(IntPtr ctx, ReadOnlySpan<byte> blob)
        {
            fixed (byte* p = blob)
            {
                NativeMethods.sqlite3_result_blob(ctx, (IntPtr) p, blob.Length, new IntPtr(-1));
            }
        }

        void ISQLite3Provider.sqlite3_result_zeroblob(IntPtr ctx, int n)
        {
            NativeMethods.sqlite3_result_zeroblob(ctx, n);
        }

        // TODO sqlite3_result_value

        void ISQLite3Provider.sqlite3_result_error_toobig(IntPtr ctx)
        {
            NativeMethods.sqlite3_result_error_toobig(ctx);
        }

        void ISQLite3Provider.sqlite3_result_error_nomem(IntPtr ctx)
        {
            NativeMethods.sqlite3_result_error_nomem(ctx);
        }

        void ISQLite3Provider.sqlite3_result_error_code(IntPtr ctx, int code)
        {
            NativeMethods.sqlite3_result_error_code(ctx, code);
        }

        ReadOnlySpan<byte> ISQLite3Provider.sqlite3_value_blob(IntPtr p)
        {
            IntPtr blobPointer = NativeMethods.sqlite3_value_blob(p);
            if (blobPointer == IntPtr.Zero)
            {
                return null;
            }

            var length = NativeMethods.sqlite3_value_bytes(p);
            unsafe
            {
                return new ReadOnlySpan<byte>(blobPointer.ToPointer(), length);
            }
        }

        int ISQLite3Provider.sqlite3_value_bytes(IntPtr p)
        {
            return NativeMethods.sqlite3_value_bytes(p);
        }

        double ISQLite3Provider.sqlite3_value_double(IntPtr p)
        {
            return NativeMethods.sqlite3_value_double(p);
        }

        int ISQLite3Provider.sqlite3_value_int(IntPtr p)
        {
            return NativeMethods.sqlite3_value_int(p);
        }

        long ISQLite3Provider.sqlite3_value_int64(IntPtr p)
        {
            return NativeMethods.sqlite3_value_int64(p);
        }

        int ISQLite3Provider.sqlite3_value_type(IntPtr p)
        {
            return NativeMethods.sqlite3_value_type(p);
        }

        unsafe utf8z ISQLite3Provider.sqlite3_value_text(IntPtr p)
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_value_text(p));
        }

        int ISQLite3Provider.sqlite3_bind_int(sqlite3_stmt stm, int paramIndex, int val)
        {
            return NativeMethods.sqlite3_bind_int(stm, paramIndex, val);
        }

        int ISQLite3Provider.sqlite3_bind_int64(sqlite3_stmt stm, int paramIndex, long val)
        {
            return NativeMethods.sqlite3_bind_int64(stm, paramIndex, val);
        }

        unsafe int ISQLite3Provider.sqlite3_bind_text(sqlite3_stmt stm, int paramIndex, ReadOnlySpan<byte> t)
        {
            fixed (byte* p_t = t)
            {
                return NativeMethods.sqlite3_bind_text(stm, paramIndex, p_t, t.Length, new IntPtr(-1));
            }
        }

        unsafe int ISQLite3Provider.sqlite3_bind_text16(sqlite3_stmt stm, int paramIndex, ReadOnlySpan<char> t)
        {
            fixed (char* p_t = t)
            {
                // mul span length times 2 to get num bytes, which is what sqlite wants
                return NativeMethods.sqlite3_bind_text16(stm, paramIndex, p_t, t.Length * 2, new IntPtr(-1));
            }
        }

        unsafe int ISQLite3Provider.sqlite3_bind_text(sqlite3_stmt stm, int paramIndex, utf8z t)
        {
            fixed (byte* p_t = t)
            {
                return NativeMethods.sqlite3_bind_text(stm, paramIndex, p_t, -1, new IntPtr(-1));
            }
        }

        int ISQLite3Provider.sqlite3_bind_double(sqlite3_stmt stm, int paramIndex, double val)
        {
            return NativeMethods.sqlite3_bind_double(stm, paramIndex, val);
        }

        unsafe int ISQLite3Provider.sqlite3_bind_blob(sqlite3_stmt stm, int paramIndex, ReadOnlySpan<byte> blob)
        {
            if (blob.Length == 0)
            {
                // passing a zero-length blob to sqlite3_bind_blob() requires
                // a non-null pointer, even though conceptually, that pointer
                // point to zero things, ie nothing.

                var ba_fake = new byte[] { 42 };
                ReadOnlySpan<byte> span_fake = ba_fake;
                fixed (byte* p_fake = span_fake)
                {
                    return NativeMethods.sqlite3_bind_blob(stm, paramIndex, p_fake, 0, new IntPtr(-1));
                }
            }
            else
            {
                fixed (byte* p = blob)
                {
                    return NativeMethods.sqlite3_bind_blob(stm, paramIndex, p, blob.Length, new IntPtr(-1));
                }
            }
        }

        int ISQLite3Provider.sqlite3_bind_zeroblob(sqlite3_stmt stm, int paramIndex, int size)
        {
            return NativeMethods.sqlite3_bind_zeroblob(stm, paramIndex, size);
        }

        int ISQLite3Provider.sqlite3_bind_null(sqlite3_stmt stm, int paramIndex)
        {
            return NativeMethods.sqlite3_bind_null(stm, paramIndex);
        }

        int ISQLite3Provider.sqlite3_bind_parameter_count(sqlite3_stmt stm)
        {
            return NativeMethods.sqlite3_bind_parameter_count(stm);
        }

        unsafe utf8z ISQLite3Provider.sqlite3_bind_parameter_name(sqlite3_stmt stm, int paramIndex)
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_bind_parameter_name(stm, paramIndex));
        }

        unsafe int ISQLite3Provider.sqlite3_bind_parameter_index(sqlite3_stmt stm, utf8z paramName)
        {
            fixed (byte* p_paramName = paramName)
            {
                return NativeMethods.sqlite3_bind_parameter_index(stm, p_paramName);
            }
        }

        int ISQLite3Provider.sqlite3_step(sqlite3_stmt stm)
        {
            return NativeMethods.sqlite3_step(stm);
        }

        int ISQLite3Provider.sqlite3_stmt_isexplain(sqlite3_stmt stm)
        {
            return NativeMethods.sqlite3_stmt_isexplain(stm);
        }

        int ISQLite3Provider.sqlite3_stmt_busy(sqlite3_stmt stm)
        {
            return NativeMethods.sqlite3_stmt_busy(stm);
        }

        int ISQLite3Provider.sqlite3_stmt_readonly(sqlite3_stmt stm)
        {
            return NativeMethods.sqlite3_stmt_readonly(stm);
        }

        int ISQLite3Provider.sqlite3_column_int(sqlite3_stmt stm, int columnIndex)
        {
            return NativeMethods.sqlite3_column_int(stm, columnIndex);
        }

        long ISQLite3Provider.sqlite3_column_int64(sqlite3_stmt stm, int columnIndex)
        {
            return NativeMethods.sqlite3_column_int64(stm, columnIndex);
        }

        unsafe utf8z ISQLite3Provider.sqlite3_column_text(sqlite3_stmt stm, int columnIndex)
        {
            byte* p = NativeMethods.sqlite3_column_text(stm, columnIndex);
            var length = NativeMethods.sqlite3_column_bytes(stm, columnIndex);
            return utf8z.FromPtrLen(p, length);
        }

        unsafe utf8z ISQLite3Provider.sqlite3_column_decltype(sqlite3_stmt stm, int columnIndex)
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_column_decltype(stm, columnIndex));
        }

        double ISQLite3Provider.sqlite3_column_double(sqlite3_stmt stm, int columnIndex)
        {
            return NativeMethods.sqlite3_column_double(stm, columnIndex);
        }

        ReadOnlySpan<byte> ISQLite3Provider.sqlite3_column_blob(sqlite3_stmt stm, int columnIndex)
        {
            IntPtr blobPointer = NativeMethods.sqlite3_column_blob(stm, columnIndex);
            if (blobPointer == IntPtr.Zero)
            {
                return null;
            }

            var length = NativeMethods.sqlite3_column_bytes(stm, columnIndex);
            unsafe
            {
                return new ReadOnlySpan<byte>(blobPointer.ToPointer(), length);
            }
        }

        int ISQLite3Provider.sqlite3_column_type(sqlite3_stmt stm, int columnIndex)
        {
            return NativeMethods.sqlite3_column_type(stm, columnIndex);
        }

        int ISQLite3Provider.sqlite3_column_bytes(sqlite3_stmt stm, int columnIndex)
        {
            return NativeMethods.sqlite3_column_bytes(stm, columnIndex);
        }

        int ISQLite3Provider.sqlite3_column_count(sqlite3_stmt stm)
        {
            return NativeMethods.sqlite3_column_count(stm);
        }

        int ISQLite3Provider.sqlite3_data_count(sqlite3_stmt stm)
        {
            return NativeMethods.sqlite3_data_count(stm);
        }

        unsafe utf8z ISQLite3Provider.sqlite3_column_name(sqlite3_stmt stm, int columnIndex)
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_column_name(stm, columnIndex));
        }

        unsafe utf8z ISQLite3Provider.sqlite3_column_origin_name(sqlite3_stmt stm, int columnIndex)
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_column_origin_name(stm, columnIndex));
        }

        unsafe utf8z ISQLite3Provider.sqlite3_column_table_name(sqlite3_stmt stm, int columnIndex)
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_column_table_name(stm, columnIndex));
        }

        unsafe utf8z ISQLite3Provider.sqlite3_column_database_name(sqlite3_stmt stm, int columnIndex)
        {
            return utf8z.FromPtr(NativeMethods.sqlite3_column_database_name(stm, columnIndex));
        }

        int ISQLite3Provider.sqlite3_reset(sqlite3_stmt stm)
        {
            return NativeMethods.sqlite3_reset(stm);
        }

        int ISQLite3Provider.sqlite3_clear_bindings(sqlite3_stmt stm)
        {
            return NativeMethods.sqlite3_clear_bindings(stm);
        }

        int ISQLite3Provider.sqlite3_stmt_status(sqlite3_stmt stm, int op, int resetFlg)
        {
            return NativeMethods.sqlite3_stmt_status(stm, op, resetFlg);
        }

        int ISQLite3Provider.sqlite3_finalize(IntPtr stm)
        {
            return NativeMethods.sqlite3_finalize(stm);
        }

        int ISQLite3Provider.sqlite3_wal_autocheckpoint(sqlite3 db, int n)
        {
            return NativeMethods.sqlite3_wal_autocheckpoint(db, n);
        }

        unsafe int ISQLite3Provider.sqlite3_wal_checkpoint(sqlite3 db, utf8z dbName)
        {
            fixed (byte* p_dbName = dbName)
            {
                return NativeMethods.sqlite3_wal_checkpoint(db, p_dbName);
            }
        }

        unsafe int ISQLite3Provider.sqlite3_wal_checkpoint_v2(sqlite3 db, utf8z dbName, int eMode, out int logSize, out int framesCheckPointed)
        {
            fixed (byte* p_dbName = dbName)
            {
                return NativeMethods.sqlite3_wal_checkpoint_v2(db, p_dbName, eMode, out logSize, out framesCheckPointed);
            }
        }

		int ISQLite3Provider.sqlite3_keyword_count()
		{
			return NativeMethods.sqlite3_keyword_count();
		}

		unsafe int ISQLite3Provider.sqlite3_keyword_name(int i, out string name)
		{
			var rc = NativeMethods.sqlite3_keyword_name(i, out var p_name, out var length);

			// p_name is NOT null-terminated
			name = Encoding.UTF8.GetString(p_name, length);
			return rc;
		}

        unsafe IntPtr ISQLite3Provider.sqlite3_serialize(sqlite3 db, utf8z schema, out long size, uint flags)
        {
            fixed (byte* p_schema = schema)
            {
                return NativeMethods.sqlite3_serialize(db, p_schema, out size, flags);
            }
        }

        unsafe int ISQLite3Provider.sqlite3_deserialize(sqlite3 db, utf8z schema, IntPtr data, long szDb, long szBuf, uint flags)
        {
            fixed (byte* p_schema = schema)
            {
                return NativeMethods.sqlite3_deserialize(db, p_schema, data, szDb, szBuf, flags);
            }
        }

	static class NativeMethods
	{
<#
	if (KIND == "dynamic")
	{
		write_dynamic_load_stuff();
	}
	else if (KIND == "dllimport")
	{
#>
        private const string SQLITE_DLL = "<#= NAME_FOR_DLLIMPORT #>";

<#
		write_api_entries(KIND);
	}
    if (FEATURE_FUNCPTRS != "FEATURE_FUNCPTRS/false")
    {
    }
    else
    {
        write_callback_delegates();
    }
#>
	}

<#
	if (KIND == "dynamic")
	{
#>
	static class MyDelegateTypes
	{
<#
	write_api_entries(KIND);
#>
	}
<#
	}
#>

    }
}
<#+
    class Parm
    {
        public string typ { get; private set; }
        public string nam { get; private set; }
        public bool isOut { get; private set; }
        public Parm(string t, string n)
        {
            typ = t;
            nam = n;
        }
        public Parm SetIsOut(bool b)
        {
            isOut = b;
            return this;
        }
    }
    class Function
    {
        public string ret { get; private set; }
        public string nam { get; private set; }
        public Parm[] parms { get; private set; }
        public Parm[] extra_parms { get; private set; }
        public string entry { get; private set; }
        public bool varargs { get; private set; }
        public string feature { get; private set; }
        public Function(string r, string n, Parm[] p)
        {
            ret = r;
            nam = n;
            parms = p;
        }
        // TODO this should probably return IEnumerable<Parm> and use Concat/Append/whatever
        public Parm[] GetAllParms()
        {
            var a = new System.Collections.Generic.List<Parm>();
            a.AddRange(parms);
            if (varargs && extra_parms != null)
            {
                a.AddRange(extra_parms);
            }
            return a.ToArray();
        }
        public Function SetEntryPoint(string e)
        {
            entry = e;
            return this;
        }
        public Function SetExtraParms(Parm[] a)
        {
            extra_parms = a;
            return this;
        }
        public Function SetVarArgs(bool b)
        {
            varargs = b;
            return this;
        }
        public Function SetFeature(string f)
        {
            feature = f;
            return this;
        }
    }

    Function[] a_funcs = new Function[] {
        new Function(
            "int",
            "sqlite3_close",
            new Parm[] {
                new Parm("IntPtr", "db"),
            }
            ),
        new Function(
            "int",
            "sqlite3_close_v2",
            new Parm[] {
                new Parm("IntPtr", "db"),
            }
            ),
        new Function(
            "int",
            "sqlite3_enable_shared_cache",
            new Parm[] {
                new Parm("int", "enable"),
            }
            ),
        new Function(
            "void",
            "sqlite3_interrupt",
            new Parm[] {
                new Parm("sqlite3", "db"),
            }
            ),
        new Function(
            "int",
            "sqlite3_finalize",
            new Parm[] {
                new Parm("IntPtr", "stmt"),
            }
            ),
        new Function(
            "int",
            "sqlite3_reset",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
            }
            ),
        new Function(
            "int",
            "sqlite3_clear_bindings",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
            }
            ),
        new Function(
            "int",
            "sqlite3_stmt_status",
            new Parm[] {
                new Parm("sqlite3_stmt", "stm"),
                new Parm("int", "op"),
                new Parm("int", "resetFlg"),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_bind_parameter_name",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_column_database_name",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_column_decltype",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_column_name",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_column_origin_name",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_column_table_name",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_column_text",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_errmsg",
            new Parm[] {
                new Parm("sqlite3", "db"),
            }
            ),
        new Function(
            "int",
            "sqlite3_db_readonly",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "dbName"),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_db_filename",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "att"),
            }
            ),
        new Function(
            "int",
            "sqlite3_prepare_v2",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "pSql"),
                new Parm("int", "nBytes"),
                new Parm("IntPtr", "stmt").SetIsOut(true),
                new Parm("byte*", "ptrRemain").SetIsOut(true),
            }
            ),
        new Function(
            "int",
            "sqlite3_prepare_v3",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "pSql"),
                new Parm("int", "nBytes"),
                new Parm("uint", "flags"),
                new Parm("IntPtr", "stmt").SetIsOut(true),
                new Parm("byte*", "ptrRemain").SetIsOut(true),
            }
            ),
        new Function(
            "int",
            "sqlite3_db_status",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("int", "op"),
                new Parm("int", "current").SetIsOut(true),
                new Parm("int", "highest").SetIsOut(true),
                new Parm("int", "resetFlg"),
            }
            ),
        new Function(
            "int",
            "sqlite3_complete",
            new Parm[] {
                new Parm("byte*", "pSql"),
            }
            ),
        new Function(
            "int",
            "sqlite3_compileoption_used",
            new Parm[] {
                new Parm("byte*", "pSql"),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_compileoption_get",
            new Parm[] {
                new Parm("int", "n"),
            }
            ),
        new Function(
            "int",
            "sqlite3_table_column_metadata",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "dbName"),
                new Parm("byte*", "tblName"),
                new Parm("byte*", "colName"),
                new Parm("byte*", "ptrDataType").SetIsOut(true),
                new Parm("byte*", "ptrCollSeq").SetIsOut(true),
                new Parm("int", "notNull").SetIsOut(true),
                new Parm("int", "primaryKey").SetIsOut(true),
                new Parm("int", "autoInc").SetIsOut(true),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_value_text",
            new Parm[] {
                new Parm("IntPtr", "p"),
            }
            ),
        new Function(
            "int",
            "sqlite3_enable_load_extension",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("int", "enable"),
            }
            ),
        new Function(
            "int",
            "sqlite3_load_extension",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "zFile"),
                new Parm("byte*", "zProc"),
                new Parm("byte*", "pzErrMsg").SetIsOut(true),
            }
            )
            .SetFeature("loadextension")
            ,
        new Function(
            "int",
            "sqlite3_limit",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("int", "id"),
                new Parm("int", "newVal"),
            }
            ),
        new Function(
            "int",
            "sqlite3_initialize",
            new Parm[] {
            }
            ),
        new Function(
            "int",
            "sqlite3_shutdown",
            new Parm[] {
            }
            ),
        new Function(
            "byte*",
            "sqlite3_libversion",
            new Parm[] {
            }
            ),
        new Function(
            "int",
            "sqlite3_libversion_number",
            new Parm[] {
            }
            ),
        new Function(
            "int",
            "sqlite3_threadsafe",
            new Parm[] {
            }
            ),
        new Function(
            "byte*",
            "sqlite3_sourceid",
            new Parm[] {
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_malloc",
            new Parm[] {
                new Parm("int", "n"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_malloc64",
            new Parm[] {
                new Parm("ulong", "n"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_realloc",
            new Parm[] {
                new Parm("IntPtr", "p"),
                new Parm("int", "n"),
            }
            ),
        new Function(
            "void",
            "sqlite3_free",
            new Parm[] {
                new Parm("IntPtr", "p"),
            }
            ),
        new Function(
            "int",
            "sqlite3_stricmp",
            new Parm[] {
                new Parm("IntPtr", "p"),
                new Parm("IntPtr", "q"),
            }
            ),
        new Function(
            "int",
            "sqlite3_strnicmp",
            new Parm[] {
                new Parm("IntPtr", "p"),
                new Parm("IntPtr", "q"),
                new Parm("int", "n"),
            }
            ),
        new Function(
            "int",
            "sqlite3_open",
            new Parm[] {
                new Parm("byte*", "filename"),
                new Parm("IntPtr", "db").SetIsOut(true),
            }
            ),
        new Function(
            "int",
            "sqlite3_open_v2",
            new Parm[] {
                new Parm("byte*", "filename"),
                new Parm("IntPtr", "db").SetIsOut(true),
                new Parm("int", "flags"),
                new Parm("byte*", "vfs"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_vfs_find",
            new Parm[] {
                new Parm("byte*", "vfs"),
            }
            ),
        new Function(
            "long",
            "sqlite3_last_insert_rowid",
            new Parm[] {
                new Parm("sqlite3", "db"),
            }
            ),
        new Function(
            "int",
            "sqlite3_changes",
            new Parm[] {
                new Parm("sqlite3", "db"),
            }
            ),
        new Function(
            "int",
            "sqlite3_total_changes",
            new Parm[] {
                new Parm("sqlite3", "db"),
            }
            ),
        new Function(
            "long",
            "sqlite3_memory_used",
            new Parm[] {
            }
            ),
        new Function(
            "long",
            "sqlite3_memory_highwater",
            new Parm[] {
                new Parm("int", "resetFlag"),
            }
            ),
        new Function(
            "long",
            "sqlite3_soft_heap_limit64",
            new Parm[] {
                new Parm("long", "n"),
            }
            ),
        new Function(
            "long",
            "sqlite3_hard_heap_limit64",
            new Parm[] {
                new Parm("long", "n"),
            }
            ),
        new Function(
            "int",
            "sqlite3_status",
            new Parm[] {
                new Parm("int", "op"),
                new Parm("int", "current").SetIsOut(true),
                new Parm("int", "highwater").SetIsOut(true),
                new Parm("int", "resetFlag"),
            }
            ),
        new Function(
            "int",
            "sqlite3_busy_timeout",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("int", "ms"),
            }
            ),
        new Function(
            "int",
            "sqlite3_bind_blob",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
                new Parm("byte*", "val"),
                new Parm("int", "nSize"),
                new Parm("IntPtr", "nTransient"),
            }
            ),
        new Function(
            "int",
            "sqlite3_bind_zeroblob",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
                new Parm("int", "size"),
            }
            ),
        new Function(
            "int",
            "sqlite3_bind_double",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
                new Parm("double", "val"),
            }
            ),
        new Function(
            "int",
            "sqlite3_bind_int",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
                new Parm("int", "val"),
            }
            ),
        new Function(
            "int",
            "sqlite3_bind_int64",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
                new Parm("long", "val"),
            }
            ),
        new Function(
            "int",
            "sqlite3_bind_null",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "int",
            "sqlite3_bind_text",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
                new Parm("byte*", "val"),
                new Parm("int", "nlen"),
                new Parm("IntPtr", "pvReserved"),
            }
            ),
        new Function(
            "int",
            "sqlite3_bind_text16",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
                new Parm("char*", "val"),
                new Parm("int", "nlen"),
                new Parm("IntPtr", "pvReserved"),
            }
            ),
        new Function(
            "int",
            "sqlite3_bind_parameter_count",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
            }
            ),
        new Function(
            "int",
            "sqlite3_bind_parameter_index",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("byte*", "strName"),
            }
            ),
        new Function(
            "int",
            "sqlite3_column_count",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
            }
            ),
        new Function(
            "int",
            "sqlite3_data_count",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
            }
            ),
        new Function(
            "int",
            "sqlite3_step",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_sql",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
            }
            ),
        new Function(
            "double",
            "sqlite3_column_double",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "int",
            "sqlite3_column_int",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "long",
            "sqlite3_column_int64",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_column_blob",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "int",
            "sqlite3_column_bytes",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "int",
            "sqlite3_column_type",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
                new Parm("int", "index"),
            }
            ),
        new Function(
            "int",
            "sqlite3_aggregate_count",
            new Parm[] {
                new Parm("IntPtr", "context"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_value_blob",
            new Parm[] {
                new Parm("IntPtr", "p"),
            }
            ),
        new Function(
            "int",
            "sqlite3_value_bytes",
            new Parm[] {
                new Parm("IntPtr", "p"),
            }
            ),
        new Function(
            "double",
            "sqlite3_value_double",
            new Parm[] {
                new Parm("IntPtr", "p"),
            }
            ),
        new Function(
            "int",
            "sqlite3_value_int",
            new Parm[] {
                new Parm("IntPtr", "p"),
            }
            ),
        new Function(
            "long",
            "sqlite3_value_int64",
            new Parm[] {
                new Parm("IntPtr", "p"),
            }
            ),
        new Function(
            "int",
            "sqlite3_value_type",
            new Parm[] {
                new Parm("IntPtr", "p"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_user_data",
            new Parm[] {
                new Parm("IntPtr", "context"),
            }
            ),
        new Function(
            "void",
            "sqlite3_result_blob",
            new Parm[] {
                new Parm("IntPtr", "context"),
                new Parm("IntPtr", "val"),
                new Parm("int", "nSize"),
                new Parm("IntPtr", "pvReserved"),
            }
            ),
        new Function(
            "void",
            "sqlite3_result_double",
            new Parm[] {
                new Parm("IntPtr", "context"),
                new Parm("double", "val"),
            }
            ),
        new Function(
            "void",
            "sqlite3_result_error",
            new Parm[] {
                new Parm("IntPtr", "context"),
                new Parm("byte*", "strErr"),
                new Parm("int", "nLen"),
            }
            ),
        new Function(
            "void",
            "sqlite3_result_int",
            new Parm[] {
                new Parm("IntPtr", "context"),
                new Parm("int", "val"),
            }
            ),
        new Function(
            "void",
            "sqlite3_result_int64",
            new Parm[] {
                new Parm("IntPtr", "context"),
                new Parm("long", "val"),
            }
            ),
        new Function(
            "void",
            "sqlite3_result_null",
            new Parm[] {
                new Parm("IntPtr", "context"),
            }
            ),
        new Function(
            "void",
            "sqlite3_result_text",
            new Parm[] {
                new Parm("IntPtr", "context"),
                new Parm("byte*", "val"),
                new Parm("int", "nLen"),
                new Parm("IntPtr", "pvReserved"),
            }
            ),
        new Function(
            "void",
            "sqlite3_result_zeroblob",
            new Parm[] {
                new Parm("IntPtr", "context"),
                new Parm("int", "n"),
            }
            ),
        new Function(
            "void",
            "sqlite3_result_error_toobig",
            new Parm[] {
                new Parm("IntPtr", "context"),
            }
            ),
        new Function(
            "void",
            "sqlite3_result_error_nomem",
            new Parm[] {
                new Parm("IntPtr", "context"),
            }
            ),
        new Function(
            "void",
            "sqlite3_result_error_code",
            new Parm[] {
                new Parm("IntPtr", "context"),
                new Parm("int", "code"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_aggregate_context",
            new Parm[] {
                new Parm("IntPtr", "context"),
                new Parm("int", "nBytes"),
            }
            ),
        new Function(
            "int",
            "sqlite3_key",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "key"),
                new Parm("int", "keylen"),
            }
            )
            .SetFeature("key")
            ,
        new Function(
            "int",
            "sqlite3_key_v2",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "dbname"),
                new Parm("byte*", "key"),
                new Parm("int", "keylen"),
            }
            )
            .SetFeature("key")
            ,
        new Function(
            "int",
            "sqlite3_rekey",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "key"),
                new Parm("int", "keylen"),
            }
            )
            .SetFeature("key")
            ,
        new Function(
            "int",
            "sqlite3_rekey_v2",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "dbname"),
                new Parm("byte*", "key"),
                new Parm("int", "keylen"),
            }
            )
            .SetFeature("key")
            ,
        // Since sqlite3_config() takes a variable argument list, we have to overload declarations
        // for all possible calls that we want to use.
        new Function(
            "int",
            "sqlite3_config_none",
            new Parm[] {
                new Parm("int", "op"),
            }
            )
            .SetEntryPoint("sqlite3_config")
            .SetVarArgs(true)
            ,
        new Function(
            "int",
            "sqlite3_config_int",
            new Parm[] {
                new Parm("int", "op"),
            }
            )
            .SetExtraParms(
                new Parm[] {
                    new Parm("int", "val"),
                }
            )
            .SetEntryPoint("sqlite3_config")
            .SetVarArgs(true)
            ,
        new Function(
            "int",
            "sqlite3_config_log",
            new Parm[] {
                new Parm("int", "op"),
            }
            )
            .SetExtraParms(
                new Parm[] {
                new Parm("NativeMethods.callback_log", "func"),
                new Parm("hook_handle", "pvUser"),
                }
            )
            .SetEntryPoint("sqlite3_config")
            .SetVarArgs(true)
            ,
        // Since sqlite3_db_config() takes a variable argument list, we have to overload declarations
        // for all possible calls that we want to use.
        new Function(
            "int",
            "sqlite3_db_config_charptr",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("int", "op"),
            }
            )
            .SetExtraParms(
                new Parm[] {
                    new Parm("byte*", "val"),
                }
            )
            .SetEntryPoint("sqlite3_db_config")
            .SetVarArgs(true)
            ,
        new Function(
            "int",
            "sqlite3_db_config_int_outint",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("int", "op"),
            }
            )
            .SetExtraParms(
                new Parm[] {
                    new Parm("int", "val"),
                    new Parm("int*", "result"),
                }
            )
            .SetEntryPoint("sqlite3_db_config")
            .SetVarArgs(true)
            ,
        new Function(
            "int",
            "sqlite3_db_config_intptr_int_int",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("int", "op"),
            }
            )
            .SetExtraParms(
                new Parm[] {
                    new Parm("IntPtr", "ptr"),
                    new Parm("int", "int0"),
                    new Parm("int", "int1"),
                }
            )
            .SetEntryPoint("sqlite3_db_config")
            .SetVarArgs(true)
            ,
        new Function(
            "int",
            "sqlite3_create_collation",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte[]", "strName"),
                new Parm("int", "nType"),
                new Parm("hook_handle", "pvUser"),
                new Parm("NativeMethods.callback_collation", "func"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_update_hook",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("NativeMethods.callback_update", "func"),
                new Parm("hook_handle", "pvUser"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_commit_hook",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("NativeMethods.callback_commit", "func"),
                new Parm("hook_handle", "pvUser"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_profile",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("NativeMethods.callback_profile", "func"),
                new Parm("hook_handle", "pvUser"),
            }
            ),
        new Function(
            "void",
            "sqlite3_progress_handler",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("int", "instructions"),
                new Parm("NativeMethods.callback_progress_handler", "func"),
                new Parm("hook_handle", "pvUser"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_trace",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("NativeMethods.callback_trace", "func"),
                new Parm("hook_handle", "pvUser"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_rollback_hook",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("NativeMethods.callback_rollback", "func"),
                new Parm("hook_handle", "pvUser"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_db_handle",
            new Parm[] {
                new Parm("IntPtr", "stmt"),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_next_stmt",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("IntPtr", "stmt"),
            }
            ),
        new Function(
            "int",
            "sqlite3_stmt_isexplain",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
            }
            ),
        new Function(
            "int",
            "sqlite3_stmt_busy",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
            }
            ),
        new Function(
            "int",
            "sqlite3_stmt_readonly",
            new Parm[] {
                new Parm("sqlite3_stmt", "stmt"),
            }
            ),
        new Function(
            "int",
            "sqlite3_exec",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "strSql"),
                new Parm("NativeMethods.callback_exec", "cb"),
                new Parm("hook_handle", "pvParam"),
                new Parm("IntPtr", "errMsg").SetIsOut(true),
            }
            ),
        new Function(
            "int",
            "sqlite3_get_autocommit",
            new Parm[] {
                new Parm("sqlite3", "db"),
            }
            ),
        new Function(
            "int",
            "sqlite3_extended_result_codes",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("int", "onoff"),
            }
            ),
        new Function(
            "int",
            "sqlite3_errcode",
            new Parm[] {
                new Parm("sqlite3", "db"),
            }
            ),
        new Function(
            "int",
            "sqlite3_extended_errcode",
            new Parm[] {
                new Parm("sqlite3", "db"),
            }
            ),
        new Function(
            "byte*",
            "sqlite3_errstr",
            new Parm[] {
                new Parm("int", "rc"),
            }
            ),

        // Since sqlite3_log() takes a variable argument list, we have to overload declarations
        // for all possible calls.  For now, we are only exposing a single string, and 
        // depend on the caller to format the string.
        new Function(
            "void",
            "sqlite3_log",
            new Parm[] {
                new Parm("int", "iErrCode"),
                new Parm("byte*", "zFormat"),
            }
            )
            .SetVarArgs(true)
            ,
        new Function(
            "int",
            "sqlite3_file_control",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte[]", "zDbName"),
                new Parm("int", "op"),
                new Parm("IntPtr", "pArg"),
            }
            ),
        new Function(
            "sqlite3_backup",
            "sqlite3_backup_init",
            new Parm[] {
                new Parm("sqlite3", "destDb"),
                new Parm("byte*", "zDestName"),
                new Parm("sqlite3", "sourceDb"),
                new Parm("byte*", "zSourceName"),
            }
            ),
        new Function(
            "int",
            "sqlite3_backup_step",
            new Parm[] {
                new Parm("sqlite3_backup", "backup"),
                new Parm("int", "nPage"),
            }
            ),
        new Function(
            "int",
            "sqlite3_backup_remaining",
            new Parm[] {
                new Parm("sqlite3_backup", "backup"),
            }
            ),
        new Function(
            "int",
            "sqlite3_backup_pagecount",
            new Parm[] {
                new Parm("sqlite3_backup", "backup"),
            }
            ),
        new Function(
            "int",
            "sqlite3_backup_finish",
            new Parm[] {
                new Parm("IntPtr", "backup"),
            }
            ),
        new Function(
            "int",
            "sqlite3_snapshot_get",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "schema"),
                new Parm("IntPtr", "snap").SetIsOut(true),
            }
            ),
        new Function(
            "int",
            "sqlite3_snapshot_open",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "schema"),
                new Parm("sqlite3_snapshot", "snap"),
            }
            ),
        new Function(
            "int",
            "sqlite3_snapshot_recover",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "name"),
            }
            ),
        new Function(
            "int",
            "sqlite3_snapshot_cmp",
            new Parm[] {
                new Parm("sqlite3_snapshot", "p1"),
                new Parm("sqlite3_snapshot", "p2"),
            }
            ),
        new Function(
            "void",
            "sqlite3_snapshot_free",
            new Parm[] {
                new Parm("IntPtr", "snap"),
            }
            ),
        new Function(
            "int",
            "sqlite3_blob_open",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "sdb"),
                new Parm("byte*", "table"),
                new Parm("byte*", "col"),
                new Parm("long", "rowid"),
                new Parm("int", "flags"),
                new Parm("sqlite3_blob", "blob").SetIsOut(true),
            }
            ),
        new Function(
            "int",
            "sqlite3_blob_write",
            new Parm[] {
                new Parm("sqlite3_blob", "blob"),
                new Parm("byte*", "b"),
                new Parm("int", "n"),
                new Parm("int", "offset"),
            }
            ),
        new Function(
            "int",
            "sqlite3_blob_read",
            new Parm[] {
                new Parm("sqlite3_blob", "blob"),
                new Parm("byte*", "b"),
                new Parm("int", "n"),
                new Parm("int", "offset"),
            }
            ),
        new Function(
            "int",
            "sqlite3_blob_bytes",
            new Parm[] {
                new Parm("sqlite3_blob", "blob"),
            }
            ),
        new Function(
            "int",
            "sqlite3_blob_reopen",
            new Parm[] {
                new Parm("sqlite3_blob", "blob"),
                new Parm("long", "rowid"),
            }
            ),
        new Function(
            "int",
            "sqlite3_blob_close",
            new Parm[] {
                new Parm("IntPtr", "blob"),
            }
            ),
        new Function(
            "int",
            "sqlite3_wal_autocheckpoint",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("int", "n"),
            }
            ),
        new Function(
            "int",
            "sqlite3_wal_checkpoint",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "dbName"),
            }
            ),
        new Function(
            "int",
            "sqlite3_wal_checkpoint_v2",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "dbName"),
                new Parm("int", "eMode"),
                new Parm("int", "logSize").SetIsOut(true),
                new Parm("int", "framesCheckPointed").SetIsOut(true),
            }
            ),
        new Function(
            "int",
            "sqlite3_set_authorizer",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("NativeMethods.callback_authorizer", "cb"),
                new Parm("hook_handle", "pvUser"),
            }
            ),
        new Function(
            "int",
            "sqlite3_win32_set_directory8",
            new Parm[] {
                new Parm("uint", "directoryType"),
                new Parm("byte*", "directoryPath"),
            })
            .SetFeature("win32")
            ,
        new Function(
            "int",
            "sqlite3_create_function_v2",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte[]", "strName"),
                new Parm("int", "nArgs"),
                new Parm("int", "nType"),
                new Parm("hook_handle", "pvUser"),
                new Parm("NativeMethods.callback_scalar_function", "func"),
                new Parm("NativeMethods.callback_agg_function_step", "fstep"),
                new Parm("NativeMethods.callback_agg_function_final", "ffinal"),
                new Parm("NativeMethods.callback_destroy", "fdestroy"),
            }
            ),
        new Function(
            "int",
            "sqlite3_keyword_count",
            new Parm[] {
            }
            ),
        new Function(
            "int",
            "sqlite3_keyword_name",
            new Parm[] {
                new Parm("int", "i"),
                new Parm("byte*", "name").SetIsOut(true),
                new Parm("int", "length").SetIsOut(true),
            }
            ),
        new Function(
            "IntPtr",
            "sqlite3_serialize",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "schema"),
                new Parm("long", "size").SetIsOut(true),
                new Parm("uint", "flags"),
            }
            ),
        new Function(
            "int",
            "sqlite3_deserialize",
            new Parm[] {
                new Parm("sqlite3", "db"),
                new Parm("byte*", "schema"),
                new Parm("IntPtr", "data"),
                new Parm("long", "szDb"),
                new Parm("long", "szBuf"),
                new Parm("uint", "flags"),
            }
            ),


        };

        bool check_feature(Function f)
        {
            if (f.feature == null)
            {
                // fine
                return true;
            }
            else if (f.feature == "key")
            {
                return (FEATURE_KEY == "FEATURE_KEY/true");
            }
            else if (f.feature == "win32")
            {
                return (FEATURE_WIN32DIR == "FEATURE_WIN32DIR/true");
            }
            else if (f.feature == "loadextension")
            {
                return (FEATURE_LOADEXTENSION == "FEATURE_LOADEXTENSION/true");
            }
            else
            {
                throw new NotImplementedException();
            }
        }

	void write_dynamic_load_stuff()
	{
#>
		static Delegate Load(IGetFunctionPointer gf, Type delegate_type)
		{
			// TODO check here to make sure the type is a delegate of some kind?
			// just in case we introduce other properties later?
			var name = delegate_type.Name;
			foreach (var attr in delegate_type.GetTypeInfo().GetCustomAttributes())
			{
				if (attr.GetType() == typeof(EntryPointAttribute))
				{
					var ep = attr as EntryPointAttribute;
					//System.Console.WriteLine("{0} EntryPoint {1}", name, ep.Name);
					name = ep.Name;
				}
			}
			var fn_ptr = gf.GetFunctionPointer(name);
			if (fn_ptr != IntPtr.Zero)
			{
				var d = Marshal.GetDelegateForFunctionPointer(fn_ptr, delegate_type);
				return d;
			}
			else
			{
				//System.Console.WriteLine("Warning: {0} not found", name);
				return null;
			}
		}

		static public void Setup(IGetFunctionPointer gf)
		{
<#+
	foreach (var f in a_funcs)
	{
        if (check_feature(f))
        {
        var s = f.nam;
#>
			<#= s #> = (MyDelegateTypes.<#= s #>) Load(gf, typeof(MyDelegateTypes.<#= s #>));
<#+
        if (f.varargs && f.extra_parms != null)
        {
#>
			<#= s #>_arm64cc = (MyDelegateTypes.<#= s #>_arm64cc) Load(gf, typeof(MyDelegateTypes.<#= s #>_arm64cc));
<#+
        }
        }
	}
#>
		}

<#+
	foreach (var f in a_funcs)
	{
        if (check_feature(f))
        {
        var s = f.nam;
#>
		public static MyDelegateTypes.<#= s #> <#= s #>;
<#+
        if (f.varargs && f.extra_parms != null)
        {
#>
		public static MyDelegateTypes.<#= s #>_arm64cc <#= s #>_arm64cc;
<#+
        }
        }
	}
	}
	void write_callback_delegates()
	{
#>
	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate void callback_log(IntPtr pUserData, int errorCode, IntPtr pMessage);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate void callback_scalar_function(IntPtr context, int nArgs, IntPtr argsptr);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate void callback_agg_function_step(IntPtr context, int nArgs, IntPtr argsptr);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate void callback_agg_function_final(IntPtr context);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate void callback_destroy(IntPtr p);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate int callback_collation(IntPtr puser, int len1, IntPtr pv1, int len2, IntPtr pv2);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate void callback_update(IntPtr p, int typ, IntPtr db, IntPtr tbl, long rowid);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate int callback_commit(IntPtr puser);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate void callback_profile(IntPtr puser, IntPtr statement, long elapsed);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate int callback_progress_handler(IntPtr puser);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate int callback_authorizer(IntPtr puser, int action_code, IntPtr param0, IntPtr param1, IntPtr dbName, IntPtr inner_most_trigger_or_view);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate void callback_trace(IntPtr puser, IntPtr statement);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate void callback_rollback(IntPtr puser);

	[UnmanagedFunctionPointer(CALLING_CONVENTION)]
	public delegate int callback_exec(IntPtr db, int n, IntPtr values, IntPtr names);
<#+
	}

	void write_api_entries(string k)
	{
        System.Collections.Generic.List<string> get_parm_list(Function f, bool arm64cc = false)
        {
            string get_fixed_parm_type(Parm p)
            {
                string typ = p.typ;
                if (FEATURE_FUNCPTRS != "FEATURE_FUNCPTRS/false")
                {
                    switch (typ)
                    {
                        case "NativeMethods.callback_commit":
                        case "NativeMethods.callback_log":
                        case "NativeMethods.callback_collation":
                        case "NativeMethods.callback_profile":
                        case "NativeMethods.callback_update":
                        case "NativeMethods.callback_progress_handler":
                        case "NativeMethods.callback_trace":
                        case "NativeMethods.callback_rollback":
                        case "NativeMethods.callback_exec":
                        case "NativeMethods.callback_scalar_function":
                        case "NativeMethods.callback_agg_function_step":
                        case "NativeMethods.callback_agg_function_final":
                        case "NativeMethods.callback_destroy":
                        case "NativeMethods.callback_authorizer":
                            // TODO wouldn't it be better to have the actual
                            // function pointer type for each case here?
                            typ = "IntPtr";
                            break;
                        default:
                            break;
                    }
                }
                return typ;
            }
            var a_parms = new System.Collections.Generic.List<string>();
            foreach (var p in f.parms)
            {
                string typ = get_fixed_parm_type(p);
                a_parms.Add((p.isOut ? "out " : "") + typ + " " + p.nam);
            }
            if (f.varargs && f.extra_parms != null)
            {
                if (arm64cc)
                {
                    for (int i = a_parms.Count; i < 8; i++)
                    {
                        a_parms.Add("IntPtr dummy" + i);
                    }
                }
                foreach (var p in f.extra_parms)
                {
                    if (p.isOut) throw new Exception();
                    string typ = get_fixed_parm_type(p);
                    a_parms.Add(typ + " " + p.nam);
                }
            }
            return a_parms;
        }

        void write_method(Function f)
        {
            if (!check_feature(f))
            {
                return;
            }
            {
                var a_parms = get_parm_list(f);

                string front;
                string attr;
                if (k == "dynamic")
                {
                    front = "public unsafe delegate";
                    if (f.entry == null)
                    {
                        attr = "[UnmanagedFunctionPointer(CALLING_CONVENTION)]";
                    }
                    else
                    {
                        attr = $"[UnmanagedFunctionPointer(CALLING_CONVENTION)]\n\t\t[EntryPoint(\"{f.entry}\")]";
                    }
                }
                else if (k == "dllimport")
                {
                    front = "public static extern unsafe";
                    if (f.entry == null)
                    {
                        attr = "[DllImport(SQLITE_DLL, ExactSpelling=true, CallingConvention = CALLING_CONVENTION)]";
                    }
                    else
                    {
                        attr = $"[DllImport(SQLITE_DLL, ExactSpelling=true, EntryPoint = \"{f.entry}\", CallingConvention = CALLING_CONVENTION)]";
                    }
                }
                else
                {
                    throw new NotImplementedException();
                }

#>
		<#= attr #>
		<#= front #> <#= f.ret #> <#= f.nam #>(<#= string.Join(", ", a_parms) #>);

<#+
                if (f.varargs && f.extra_parms != null)
                {
#>
		<#= attr #>
		<#= front #> <#= f.ret #> <#= f.nam #>_arm64cc(<#= string.Join(", ", get_parm_list(f, arm64cc: true)) #>);

<#+
                }
            }
        }

            foreach (var f in a_funcs)
            {
                write_method(f);
            }
	}
#>
